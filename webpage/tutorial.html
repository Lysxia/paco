<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.18: http://docutils.sourceforge.net/" />
<title>tutorial.rst</title>
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="pygments.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document">


<pre class="alectryon-io highlight"><!-- Generator: Alectryon --><span class="alectryon-wsp"><span class="sd">(** printing \2/ $\cup$ #&amp;cup;# *)</span>
<span class="sd">(** printing &lt;2= $\subseteq$ #&amp;sube;# *)</span>
<span class="sd">(** printing forall $\forall$ #&amp;forall;# *)</span>
<span class="sd">(** printing -&gt; $\rightarrow$ #&amp;rarr;# *)</span>
<span class="sd">(** printing /\ $\land$ #&amp;and;# *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Setoid Program.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Require Import</span> Paco.paco.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** * Illustrating the [paco] library</span>

<span class="sd">    This tutorial shows how to use our [paco] library to reason about</span>
<span class="sd">    coinductive predicates in Coq.  By coinductive predicates we mean</span>
<span class="sd">    objects that one can define using [CoInductive] and whose type</span>
<span class="sd">    ends in [Prop].  The library implements _parameterized</span>
<span class="sd">    coinduction_, as described in our draft paper entitled #&lt;a</span>
<span class="sd">    href=&quot; http://plv.mpi-sws.org/paco/&quot;&gt;# _The Power of</span>
<span class="sd">    Parameterization in Coinductive Proof_ #&lt;/a&gt;#.</span>

<span class="sd">    How does parameterized coinduction compare to Coq&#39;s existing</span>
<span class="sd">    support for coinductive proofs?</span>

<span class="sd">    For proofs by _induction_, Coq provides a tactic called [fix], but</span>
<span class="sd">    proofs done directly with [fix] are required to satisfy a</span>
<span class="sd">    _syntactic guardedness_ criterion.  Fortunately, Coq also</span>
<span class="sd">    generates induction _lemmas_ for every inductive definition, which</span>
<span class="sd">    eliminate the need to ever use the low-level [fix] tactic and</span>
<span class="sd">    worry about guardedness.  For proofs by coinduction, Coq provides</span>
<span class="sd">    a tactic [cofix] analogous to [fix], i.e., also based on a</span>
<span class="sd">    syntactic guardedness criterion.  However, Coq does not generate</span>
<span class="sd">    any lemmas for coinductive definitions.  Consequently, to reason</span>
<span class="sd">    about such definitions, the user must use the low-level [cofix]</span>
<span class="sd">    tactic.  Due to its syntactic nature, [cofix] is problematic in</span>
<span class="sd">    several ways (please see the paper linked above for detailed</span>
<span class="sd">    discussion of these points):</span>

<span class="sd">    - It is non-compositional.</span>
<span class="sd">    - It is inefficient.</span>
<span class="sd">    - It is not user-friendly.</span>
<span class="sd">    - It interacts poorly with builtin automation tactics.</span>


<span class="sd">    The [paco] library provides a tactic, [pcofix], which can be seen</span>
<span class="sd">    as a replacement for Coq&#39;s builtin [cofix] tactic (in the case of</span>
<span class="sd">    predicates) that does not involve any syntactic guardedness</span>
<span class="sd">    criterion and thus avoids all of these problems.  In addition,</span>
<span class="sd">    like Coq&#39;s [cofix], [pcofix] provides built-in support for</span>
<span class="sd">    _incremental_ proofs, i.e., proofs in which the coinduction</span>
<span class="sd">    hypothesis is extended gradually as the proof progresses.</span>

<span class="sd">    We believe this combination of compositionality, incrementality,</span>
<span class="sd">    robustness, and ease of use makes [pcofix] a superior alternative</span>
<span class="sd">    to [cofix] for proofs about coinductive predicates.</span>

<span class="sd">    The rest of this tutorial illustrates the use of the [paco]</span>
<span class="sd">    library with the help of three examples.</span>
<span class="sd">*)</span><span class="c">(* *)</span>



<span class="sd">(** ** Example: stream equality</span>

<span class="sd">    The first example involves streams of natural numbers and an</span>
<span class="sd">    equality thereon.  We prove a particular equality via [cofix], and</span>
<span class="sd">    then explain how that proof can be turned into one via [pcofix].</span>
<span class="sd">*)</span>


<span class="sd">(** We start by defining a type of streams of natural numbers.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">stream</span> :=
  | cons : nat -&gt; stream -&gt; stream.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** The following, seemingly useless, lemma is a common trick for</span>
<span class="sd">    working with corecursive terms such as our streams.  (It will be</span>
<span class="sd">    used in the example proofs.)  For details, see for instance #&lt;a</span>
<span class="sd">    href=&quot;http://adam.chlipala.net/cpdt/html/Coinductive.html&quot;&gt;Adam</span>
<span class="sd">    Chlipala&#39;s book on Certified Programming with Dependent</span>
<span class="sd">    Types&lt;/a&gt;#.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">sunf</span> <span class="nv">s</span> :=
  <span class="kr">match</span> s <span class="kr">with</span> cons n s&#39; =&gt; cons n s&#39; <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk0"><span class="kn">Lemma</span> <span class="nf">sunf_eq</span> : <span class="kr">forall</span> <span class="nv">s</span>, s = sunf s.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : stream, s = sunf s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">s</span> : stream, s = sunf s</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> s; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** In order to state our example equality, we define an enumeration</span>
<span class="sd">    stream and a map operation for streams.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">enumerate</span> <span class="nv">n</span> : stream :=
  cons n (enumerate (S n)).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">map</span> <span class="nv">f</span> <span class="nv">s</span> : stream :=
  <span class="kr">match</span> s <span class="kr">with</span> cons n s&#39; =&gt; cons (f n) (map f s&#39;) <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** A proof using [cofix]</span>

<span class="sd">    We will now prove, using [cofix], that for any [n] the stream</span>
<span class="sd">    [enumerate n] is equal to the stream [cons n (map S (enumerate n))].</span>
<span class="sd">*)</span>


<span class="sd">(** First, we define an equality [seq] on streams.  Usually, one would</span>
<span class="sd">    do this as follows.</span>

<span class="sd">    [CoInductive seq : stream -&gt; stream -&gt; Prop :=] #&lt;br&gt;#</span>
<span class="sd">    [  | seq_fold : forall n s1 s2 (R : seq s1 s2), seq (cons n s1) (cons n s2).]</span>

<span class="sd">    Instead, we define the generating function, [seq_gen], beforehand,</span>
<span class="sd">    and then define [seq] as its greatest fixed point using</span>
<span class="sd">    [CoInductive].  The reason is simply that we need [seq_gen] later</span>
<span class="sd">    when using [paco].  If applying parameterized coinduction to an</span>
<span class="sd">    existing development where the generating function is not</span>
<span class="sd">    explicit, it can always easily be made explicit.</span>

<span class="sd">    Note that, albeit the use of [Inductive], the definition</span>
<span class="sd">    of [seq_gen] is not recursive.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">seq_gen</span> <span class="nv">seq</span> : stream -&gt; stream -&gt; <span class="kt">Prop</span> :=
  | _seq_gen : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">s1</span> <span class="nv">s2</span> (<span class="nv">R</span> : seq s1 s2 : <span class="kt">Prop</span>), seq_gen seq (cons n s1) (cons n s2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2"><span class="kn">Hint Constructors</span> seq_gen : core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">seq</span> : stream -&gt; stream -&gt; <span class="kt">Prop</span> :=
  | seq_fold : <span class="kr">forall</span> <span class="nv">s1</span> <span class="nv">s2</span>, seq_gen seq s1 s2 -&gt; seq s1 s2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** Second, we do the actual proof.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3"><span class="kn">Theorem</span> <span class="nf">example</span> : <span class="kr">forall</span> <span class="nv">n</span>, seq (enumerate n) (cons n (map S (enumerate n))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
seq (enumerate n) (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
seq (enumerate n) (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5"><span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, seq (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
seq (enumerate n) (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6"><span class="nb">intros</span>; <span class="nb">apply</span> seq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, seq (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq_gen seq (enumerate n)
  (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7"><span class="nb">pattern</span> (enumerate n) <span class="nb">at</span> <span class="mi">1</span>; <span class="nb">rewrite</span> sunf_eq; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, seq (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq_gen seq (cons n (enumerate (S n)))
  (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, seq (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq (enumerate (S n)) (map S (enumerate n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk9"><span class="nb">rewrite</span> (sunf_eq (enumerate n)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, seq (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq (enumerate (S n))
  (map S (cons n (enumerate (S n))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chka"><span class="nb">rewrite</span> (sunf_eq (map _ _)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, seq (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq (enumerate (S n))
  (cons (S n) (map S (enumerate (S n))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** _Note_: One might want to eliminate the use of [pattern] in the</span>
<span class="sd">    proof script by replacing the corresponding line with the</span>
<span class="sd">    following:</span>

<span class="sd">    [rewrite sunf_eq at 1; simpl.]</span>

<span class="sd">    However, doing so will result in an invalid proof (rejected at</span>
<span class="sd">    [Qed]-time).  The reason is that the proof term created by</span>
<span class="sd">    [rewrite] ... [at 1] involves some lemmas from the [Setoid]</span>
<span class="sd">    library.  Like most lemmas, these are opaque, so guardedness</span>
<span class="sd">    checking cannot inspect their proofs and thus fails.  This is a</span>
<span class="sd">    great example of two of the previously mentioned problems with the</span>
<span class="sd">    [cofix] approach, namely lack of compositionality and poor</span>
<span class="sd">    interaction with standard tactics.</span>
<span class="sd">*)</span><span class="c">(* *)</span>



<span class="sd">(** *** A proof using our [pcofix]</span>

<span class="sd">    We will now do the same proof, but using the [paco] library.  We</span>
<span class="sd">    first simply show the new (but equivalent) definition of stream</span>
<span class="sd">    equality and the new proof of the example, and then explain what</span>
<span class="sd">    is going on behind the scenes.  In both, we use [paco] constructs</span>
<span class="sd">    with suffix &quot;2&quot; because we are dealing with predicates of arity 2</span>
<span class="sd">    here.</span>

<span class="sd">    _Note_: [Paco] supports predicates of arity up to 8.  Also, it</span>
<span class="sd">    supports up to three mutually coinductive predicates (see the last</span>
<span class="sd">    example of this tutorial).  In either case, extending this is just</span>
<span class="sd">    a matter of copy and paste.</span>

<span class="sd">    We also have to prove monotonicity of the generating function</span>
<span class="sd">    [seq_gen], which can be discharged by the tactic [pmonauto], and</span>
<span class="sd">    register it in the Hint databse [paco].</span>

<span class="sd">    _Remark_: Unlike [CoInductive], [paco] does not care whether the</span>
<span class="sd">    generating function is given in a _strictly positive_ syntactic</span>
<span class="sd">    form; all that matters is that the function is monotone. More</span>
<span class="sd">    specifically, [paco2 f] is well defined for an arbitrary generating</span>
<span class="sd">    function [f] regardless of whether it is monotone or not. However,</span>
<span class="sd">    in order to ensure that [paco2 f bot2] is the greatest fixed point</span>
<span class="sd">    of [f], we need monotonicity of [f].</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">seq&#39;</span> <span class="nv">s1</span> <span class="nv">s2</span> := paco2 seq_gen bot2 s1 s2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chkb"><span class="kn">Hint Unfold</span> seq&#39; : core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chkc"><span class="kn">Lemma</span> <span class="nf">seq_gen_mon</span>: monotone2 seq_gen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">monotone2 seq_gen</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chkd"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">monotone2 seq_gen</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">pmonauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chke"><span class="kn">Hint Resolve</span> seq_gen_mon : paco.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chkf"><span class="kn">Theorem</span> <span class="nf">example&#39;</span> : <span class="kr">forall</span> <span class="nv">n</span>, seq&#39; (enumerate n) (cons n (map S (enumerate n))).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
seq&#39; (enumerate n) (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk10"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
seq&#39; (enumerate n) (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk11">pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>stream -&gt; stream -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">n</span> : nat,
paco2 seq_gen r (enumerate n)
  (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk12"><span class="nb">intros</span>; pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>stream -&gt; stream -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq_gen (upaco2 seq_gen r) (enumerate n)
  (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk13"><span class="nb">rewrite</span> sunf_eq <span class="nb">at</span> <span class="mi">1</span>; <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>stream -&gt; stream -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">seq_gen (upaco2 seq_gen r) (cons n (enumerate (S n)))
  (cons n (map S (enumerate n)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk14"><span class="nb">constructor</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>stream -&gt; stream -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 seq_gen r (enumerate (S n))
  (map S (enumerate n))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk15"><span class="nb">rewrite</span> (sunf_eq (enumerate n)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>stream -&gt; stream -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 seq_gen r (enumerate (S n))
  (map S (cons n (enumerate (S n))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk16"><span class="nb">rewrite</span> (sunf_eq (map _ _)); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>stream -&gt; stream -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span><span class="kr">forall</span> <span class="nv">n</span> : nat, r (enumerate n) (cons n (map S (enumerate n)))</span></span></span><br><span><var>n</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 seq_gen r (enumerate (S n))
  (cons (S n) (map S (enumerate (S n))))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="nb">apply</span> CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** Observe that the proof script is essentially the same as before</span>
<span class="sd">    (this is no accident).  The main change is the use of [pcofix]</span>
<span class="sd">    instead of [cofix], which allows us to avoid any syntactic</span>
<span class="sd">    guardedness checking at [Qed]-time.  As a minor benefit of that,</span>
<span class="sd">    we are able to use [rewrite] ... [at 1], which we could not do</span>
<span class="sd">    before.  *)</span>



<span class="sd">(** **** How it works:</span>

<span class="sd">    To understand [seq&#39;] and the proof of [example&#39;], we have to</span>
<span class="sd">    explain some background.  Given a monotone function [f], we call</span>
<span class="sd">    [paco2 f] the _parameterized_ greatest fixed point of [f].  For a</span>
<span class="sd">    relation [r], [paco2 f r] is defined as the greatest fixed point</span>
<span class="sd">    of the function [fun x =&gt; f (x \2/ r)].  Clearly, [paco2 f bot2]</span>
<span class="sd">    (where [bot2] is the empty relation) is just the ordinary greatest</span>
<span class="sd">    fixed point of [f].</span>

<span class="sd">    Let us look at our example domain to understand better.  A proof</span>
<span class="sd">    of [paco2 seq_gen r s1 s2] can be seen as a proof of [r &lt;2= seq -&gt;</span>
<span class="sd">    seq s1 s2], where the use of the premise is guarded</span>
<span class="sd">    _semantically_, rather than syntactically.  More precisely, [paco2</span>
<span class="sd">    seq_gen r] relates two streams iff their heads are equal and their</span>
<span class="sd">    tails are either related by [r] or again related by [paco2 seq_gen</span>
<span class="sd">    r].  Compare this to [seq], the ordinary greatest fixed point of</span>
<span class="sd">    [seq_gen], which relates two streams iff their heads are equal and</span>
<span class="sd">    their tails are again related by [seq].  This should also make it</span>
<span class="sd">    clear why our definition of [seq&#39;] is equivalent to [seq].</span>

<span class="sd">    To fold and unfold parameterized fixed points, we provide two</span>
<span class="sd">    tactics, where [upaco2 f r := paco2 f r \2/ r]:</span>

<span class="sd">    - [pfold] : when the conclusion is [paco2 f r] for some [f] and</span>
<span class="sd">      [r], [pfold] converts it to [f (upaco2 f r)]</span>
<span class="sd">    - [punfold H] : when the hypothesis [H] is [paco2 f r] for some</span>
<span class="sd">      [f] and [r], [punfold H] converts it to [f (upaco2 f r)]</span>

<span class="sd">    Other useful lemmas are:</span>

<span class="sd">    - [paco2_mon f : monotone2 (paco2 f)]</span>
<span class="sd">    - [paco2_mult f : forall r, paco2 f (paco2 f r) &lt;2= paco2 f r]</span>
<span class="sd">    - [paco2_mult_strong f : forall r, paco2 f (upaco2 f r) &lt;2= paco2 f r]</span>


<span class="sd">    We will see an example involving [paco2_mult] in a moment.  But</span>
<span class="sd">    first let us have another look at the proof scripts of [example]</span>
<span class="sd">    and [example&#39;].  In the former, after calling [cofix], the proof</span>
<span class="sd">    state is as follows:</span>

<span class="sd">    [CIH : forall n : nat, seq (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>
<span class="sd">    [============================] #&lt;br&gt;#</span>
<span class="sd">    [forall n : nat, seq (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>

<span class="sd">    In this state, the hypothesis precisely matches the conclusion,</span>
<span class="sd">    and there is nothing preventing one from simply concluding the</span>
<span class="sd">    goal directly.  Of course, if one were to do that, one&#39;s &quot;proof&quot;</span>
<span class="sd">    would be subsequently rejected by [Qed] for failing to obey</span>
<span class="sd">    syntactic guardedness.</span>

<span class="sd">    Calling [pcofix] results in a similar state, except that the added</span>
<span class="sd">    hypothesis [CIH] now governs a fresh relation variable [r], which</span>
<span class="sd">    represents the current coinduction hypothesis relating [enumerate n]</span>
<span class="sd">    and [cons n (map S (enumerate n))] for all [n].  The new goal</span>
<span class="sd">    then says that, in proving the two streams equal, we can use [r]</span>
<span class="sd">    coinductively, but only in a semantically guarded position,</span>
<span class="sd">    i.e. after unfolding [paco2 seq_gen r].  In particular, one</span>
<span class="sd">    _cannot_ apply [CIH] immediately to &quot;solve&quot; the goal:</span>

<span class="sd">    [r : stream -&gt; stream -&gt; Prop] #&lt;br&gt;#</span>
<span class="sd">    [CIH : forall n : nat, r (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>
<span class="sd">    [============================] #&lt;br&gt;#</span>
<span class="sd">    [forall n : nat, paco2 seq_gen r (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>

<span class="sd">    The remaining differences between the proof scripts of [example]</span>
<span class="sd">    and [example&#39;] are as follows.  First, let us examine [example].</span>
<span class="sd">    After applying [seq_fold] and unfolding [enumerate n] in the proof</span>
<span class="sd">    of [example], we have the following goal:</span>

<span class="sd">    [CIH : forall n : nat, seq (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>
<span class="sd">    [n : nat] #&lt;br&gt;#</span>
<span class="sd">    [============================] #&lt;br&gt;#</span>
<span class="sd">    [seq_gen seq (cons n (enumerate (S n))) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>

<span class="sd">    By the definition of [seq_gen] and unfolding [map S (enumerate n)],</span>
<span class="sd">    this reduces to showing</span>

<span class="sd">    [CIH : forall n : nat, seq (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>
<span class="sd">    [n : nat] #&lt;br&gt;#</span>
<span class="sd">    [============================] #&lt;br&gt;#</span>
<span class="sd">    [seq (enumerate (S n)) (cons (S n) (map S (enumerate (S n))))] #&lt;br&gt;#</span>

<span class="sd">    which follows directly by applying the coinduction hypothesis [CIH].</span>

<span class="sd">    In the case of [example&#39;], the proof is slightly different.</span>
<span class="sd">    First, we use the tactic [pfold] rather than [apply seq_fold],</span>
<span class="sd">    simply because we now reason about [seq&#39;] rather than [seq].</span>
<span class="sd">    After applying [pfold] and unfolding [enumerate n], we have:</span>

<span class="sd">    [r : stream -&gt; stream -&gt; Prop] #&lt;br&gt;#</span>
<span class="sd">    [CIH : forall n : nat, r (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>
<span class="sd">    [n : nat] #&lt;br&gt;#</span>
<span class="sd">    [============================] #&lt;br&gt;#</span>
<span class="sd">    [seq_gen (paco2 seq_gen r \2/ r) (cons n (enumerate (S n))) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>

<span class="sd">    As you see, the relation [r] appears in the argument of</span>
<span class="sd">    [seq_gen]. Thus by definition of [seq_gen] and unfolding [map S</span>
<span class="sd">    (enumerate n)], we need to show [enumerate (S n)] and [cons (S n)</span>
<span class="sd">    (map S (enumerate (S n)))] are related by either [paco2 seq_gen r]</span>
<span class="sd">    or [r]:</span>

<span class="sd">    [r : stream -&gt; stream -&gt; Prop] #&lt;br&gt;#</span>
<span class="sd">    [CIH : forall n : nat, r (enumerate n) (cons n (map S (enumerate n)))] #&lt;br&gt;#</span>
<span class="sd">    [n : nat] #&lt;br&gt;#</span>
<span class="sd">    [============================] #&lt;br&gt;#</span>
<span class="sd">    [paco2 seq_gen r (enumerate (S n)) (cons (S n) (map S (enumerate (S n))))] #&lt;br&gt;#</span>
<span class="sd">    [ \/ r (enumerate (S n)) (cons (S n) (map S (enumerate (S n))))] #&lt;br&gt;#</span>

<span class="sd">    As the coinduction hypothesis gives us that they are related by [r],</span>
<span class="sd">    we first have to select the [right] disjunct, before we apply</span>
<span class="sd">    [CIH].</span>

<span class="sd">    Summing up, the two proofs are very similar, but in the one using</span>
<span class="sd">    [paco], the guardedness of the coinduction is guaranteed at every</span>
<span class="sd">    step by the way the proof is constructed, rather than by a</span>
<span class="sd">    syntactic check of the whole proof term after the fact.</span>
<span class="sd"> *)</span><span class="c">(* *)</span>



<span class="sd">(** *** Another example</span>

<span class="sd">    Before moving on to the second part, we briefly demonstrate the</span>
<span class="sd">    use of the tactics [punfold] and [pclearbot].</span>
<span class="sd">*)</span><span class="c">(* *)</span>


<span class="sd">(** Here is a proof for [seq].</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk17"><span class="kn">Theorem</span> <span class="nf">seq_cons</span> : <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">s1</span> <span class="nv">s2</span> (<span class="nv">SEQ</span> : seq (cons n1 s1) (cons n2 s2)),
  n1 = n2 /\ seq s1 s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">s1</span> <span class="nv">s2</span> : stream),
seq (cons n1 s1) (cons n2 s2) -&gt; n1 = n2 /\ seq s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk18"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">s1</span> <span class="nv">s2</span> : stream),
seq (cons n1 s1) (cons n2 s2) -&gt; n1 = n2 /\ seq s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk19"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>stream</span></span></span><br><span><var>SEQ</var><span class="hyp-type"><b>: </b><span>seq (cons n1 s1) (cons n2 s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 = n2 /\ seq s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1a"><span class="nb">inversion_clear</span> SEQ; <span class="nb">rename</span> H <span class="nb">into</span> SEQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>stream</span></span></span><br><span><var>SEQ</var><span class="hyp-type"><b>: </b><span>seq_gen seq (cons n1 s1) (cons n2 s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 = n2 /\ seq s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion_clear</span> SEQ; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** And here is the corresponding proof for [seq&#39;].</span>

<span class="sd">  Note that the tactic [pclearbot] simplifies all hypotheses of the form [upaco{n} gf bot{n}] to [paco{n} gf bot{n}].</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1b"><span class="kn">Theorem</span> <span class="nf">seq&#39;_cons</span> : <span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> <span class="nv">s1</span> <span class="nv">s2</span> (<span class="nv">SEQ</span> : seq&#39; (cons n1 s1) (cons n2 s2)),
  n1 = n2 /\ seq&#39; s1 s2.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">s1</span> <span class="nv">s2</span> : stream),
seq&#39; (cons n1 s1) (cons n2 s2) -&gt;
n1 = n2 /\ seq&#39; s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> (<span class="nv">n1</span> <span class="nv">n2</span> : nat) (<span class="nv">s1</span> <span class="nv">s2</span> : stream),
seq&#39; (cons n1 s1) (cons n2 s2) -&gt;
n1 = n2 /\ seq&#39; s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1d"><span class="nb">intros</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>stream</span></span></span><br><span><var>SEQ</var><span class="hyp-type"><b>: </b><span>seq&#39; (cons n1 s1) (cons n2 s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 = n2 /\ seq&#39; s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1e">punfold SEQ.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>n1, n2</var><span class="hyp-type"><b>: </b><span>nat</span></span></span><br><span><var>s1, s2</var><span class="hyp-type"><b>: </b><span>stream</span></span></span><br><span><var>SEQ</var><span class="hyp-type"><b>: </b><span>seq_gen (upaco2 seq_gen bot2) (cons n1 s1) (cons n2 s2)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">n1 = n2 /\ seq&#39; s1 s2</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">inversion_clear</span> SEQ; pclearbot; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
<span class="sd">(** We also provide two tactics [pdestruct] and [pinversion].</span>
<span class="sd">    They are simply defined as follows:</span>

<span class="sd">    - [pdestruct H] := [punfold H; destruct H; pclearbot]</span>
<span class="sd">    - [pinversion H] := [punfold H; inversion H; pclearbot]</span>

<span class="sd">    Using this the proof of the above theorem [seq&#39;_cons] can be</span>
<span class="sd">    simplified as [intros; pinversion SEQ; auto.]</span>
<span class="sd">*)</span><span class="c">(* *)</span>



<span class="sd">(** ** Example: infinite tree equality</span>

<span class="sd">    The second example involves infinite binary trees of natural</span>
<span class="sd">    numbers and an equality thereon.  We prove two particular</span>
<span class="sd">    equalities via [cofix] in an incremental fashion, and then show</span>
<span class="sd">    how these proofs can be done just as easily via [pcofix].</span>
<span class="sd">    We then show how, using [pcofix], the proofs can additionally</span>
<span class="sd">    be modularly decomposed.</span>

<span class="sd">*)</span>


<span class="sd">(** As before, we first define the coinductive type and the unfolding</span>
<span class="sd">    trick.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">inftree</span> :=
  | node : nat -&gt; inftree -&gt; inftree -&gt; inftree.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">tunf</span> <span class="nv">t</span> : inftree :=
  <span class="kr">match</span> t <span class="kr">with</span> node n tl tr =&gt; node n tl tr <span class="kr">end</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk1f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk1f"><span class="kn">Lemma</span> <span class="nf">tunf_eq</span> : <span class="kr">forall</span> <span class="nv">t</span>, t = tunf t.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : inftree, t = tunf t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk20"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">t</span> : inftree, t = tunf t</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> t; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** In order to state our example equalities, we define the following</span>
<span class="sd">    four trees.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">one</span> : inftree := node <span class="mi">1</span> one two
<span class="kr">with</span>       two : inftree := node <span class="mi">2</span> one two.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoFixpoint</span> <span class="nf">eins</span> : inftree := node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei)
<span class="kr">with</span>       zwei : inftree := node <span class="mi">2</span> eins zwei.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** Incremental proofs using [cofix]</span>

<span class="sd">    As before, we define the tree equality as the greatest fixed point</span>
<span class="sd">    of its generating function.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">teq_gen</span> <span class="nv">teq</span> : inftree -&gt; inftree -&gt; <span class="kt">Prop</span> :=
  | _teq_gen : <span class="kr">forall</span> <span class="nv">n</span> <span class="nv">t1l</span> <span class="nv">t1r</span> <span class="nv">t2l</span> <span class="nv">t2r</span> (<span class="nv">Rl</span> : teq t1l t2l : <span class="kt">Prop</span>) (<span class="nv">Rr</span> : teq t1r t2r),
                 teq_gen teq (node n t1l t1r) (node n t2l t2r).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk21" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk21"><span class="kn">Hint Constructors</span> teq_gen : core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">teq</span> <span class="nv">t1</span> <span class="nv">t2</span> : <span class="kt">Prop</span> :=
  | teq_fold (IN : teq_gen teq t1 t2).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** We now prove, using [cofix], that [one] equals [eins] and,</span>
<span class="sd">    separately, that [two] equals [zwei].  Note the nested use of</span>
<span class="sd">    [cofix] in either proof script, which lets us strengthen the</span>
<span class="sd">    coinductive hypothesis in the middle of the proof.  For instance,</span>
<span class="sd">    in the proof [teq_one], we start out with the coinductive</span>
<span class="sd">    hypothesis that [one] and [eins] are equal ([CIH]).  Later on, we</span>
<span class="sd">    use [cofix] again to additionally assume that [two] and [zwei] are</span>
<span class="sd">    equal ([CIH&#39;]).  This is a prime example of _incremental_ proof:</span>
<span class="sd">    we start with no coinductive assumptions, and we progressively add</span>
<span class="sd">    more coinductive assumptions as the proof progresses.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk22"><span class="kn">Theorem</span> <span class="nf">teq_one</span> : teq one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk23"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk24"><span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk25"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk26"><span class="nb">rewrite</span> (tunf_eq one), (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">1</span> one two)
  (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk27"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk28" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk28"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk29"><span class="nb">rewrite</span> (tunf_eq two); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2a"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2b"><span class="kr">cofix</span> CIH&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2c"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2d"><span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2e"><span class="kn">Theorem</span> <span class="nf">teq_two</span> : teq two zwei.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk2f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk30"><span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk31" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk31"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk32"><span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk33" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk33"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk34"><span class="kr">cofix</span> CIH&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk35" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk35"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk36" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk36"><span class="nb">rewrite</span> (tunf_eq one), (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">1</span> one two)
  (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk37"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk38" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk38"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk39" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk39"><span class="nb">rewrite</span> (tunf_eq two); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** Incremental proofs using our [pcofix]</span>

<span class="sd">    As before, we can easily turn the above [cofix]-proofs into</span>
<span class="sd">    [pcofix]-proofs.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">teq&#39;</span> <span class="nv">t1</span> <span class="nv">t2</span> := paco2 teq_gen bot2 t1 t2.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3a"><span class="kn">Hint Unfold</span> teq&#39; : core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3b"><span class="kn">Lemma</span> <span class="nf">teq_gen_mon</span>: monotone2 teq_gen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">monotone2 teq_gen</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3c"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">monotone2 teq_gen</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">pmonauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3d"><span class="kn">Hint Resolve</span> teq_gen_mon : paco.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3e"><span class="kn">Theorem</span> <span class="nf">teq&#39;_one</span> : teq&#39; one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk3f"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk40" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk40">pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk41">pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk42" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk42"><span class="nb">rewrite</span> (tunf_eq one), (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) (node <span class="mi">1</span> one two)
  (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk43"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 teq_gen r two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk44"><span class="nb">left</span>; pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk45"><span class="nb">rewrite</span> (tunf_eq two); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) (node <span class="mi">2</span> one two)
  (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk46"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk47"><span class="nb">left</span>; pcofix CIH&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk48">pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk49"><span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) 
  (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4a"><span class="kn">Theorem</span> <span class="nf">teq&#39;_two</span> : teq&#39; two zwei.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4b"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4c">pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4d">pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4e"><span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) (node <span class="mi">2</span> one two)
  (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk4f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk4f"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk50" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk50"><span class="nb">left</span>; pcofix CIH&#39;.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk51">pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk52" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk52"><span class="nb">rewrite</span> (tunf_eq one), (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) 
  (node <span class="mi">1</span> one two) (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk53" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk53"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 teq_gen r two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk54"><span class="nb">left</span>; pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk55" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk55"><span class="nb">rewrite</span> (tunf_eq two); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH'</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) 
  (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** Pseudo-compositional proofs using [cofix]</span>

<span class="sd">    It is easy to see that the proofs of [teq_one] and [teq_two] are</span>
<span class="sd">    essentially the same.  We can avoid duplicating some work by</span>
<span class="sd">    decomposing the proofs as follows.</span>

<span class="sd">    First we prove that [teq two zwei] holds under the coinductive</span>
<span class="sd">    assumption [teq one eins].  This is basically the second part of</span>
<span class="sd">    the proof of [teq_one] (and the first part of the proof of</span>
<span class="sd">    [teq_two]).  Then we prove the converse, i.e., that [teq one</span>
<span class="sd">    eins] holds under the coinductive assumption [teq two zwei].</span>
<span class="sd">    This is basically the first part of the proof of [teq_one] (and</span>
<span class="sd">    the second part of the proof of [teq_two]).</span>

<span class="sd">    The issue is that there seems to be no way to express these two</span>
<span class="sd">    properties.  The best we can do is prove [teq two zwei -&gt; teq one</span>
<span class="sd">    eins] and [teq one eins -&gt; teq two zwei], and make sure that in</span>
<span class="sd">    these proofs any use of the assumption is syntactically guarded.</span>
<span class="sd">    For instance, we are not allowed to prove [teq two zwei -&gt; teq</span>
<span class="sd">    one eins] by inspecting [teq two zwei] and extracting [teq one</span>
<span class="sd">    eins] from that (see the proof of [teq_two_one_bad] below).</span>
<span class="sd">    Although a valid proof of that goal by itself, it could not be</span>
<span class="sd">    composed later to yield a proof of [teq one eins] or [teq two</span>
<span class="sd">    zwei] (see the aborted theorem [teq_eins_bad] below).</span>

<span class="sd">    Moreover, both lemmas must then be made transparent by using</span>
<span class="sd">    [Defined] instead of [Qed] at the end, such that, when composing</span>
<span class="sd">    them to prove [teq one eins] or [teq two zwei], guardedness</span>
<span class="sd">    checking can inspect their proof terms.  In other words, [cofix]</span>
<span class="sd">    is not properly compositional.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk56" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk56"><span class="kn">Lemma</span> <span class="nf">teq_two_one_bad</span> : teq two zwei -&gt; teq one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei -&gt; teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk57"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei -&gt; teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk58" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk58"><span class="nb">intros</span>; <span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei) <span class="kr">in</span> H.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq (tunf two) (tunf zwei)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">destruct</span> H; <span class="nb">inversion</span> IN; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk59"><span class="kn">Lemma</span> <span class="nf">teq_two_one</span> : teq two zwei -&gt; teq one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei -&gt; teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei -&gt; teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5b"><span class="nb">intros</span>; <span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5c"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5d"><span class="nb">rewrite</span> (tunf_eq one), (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">1</span> one two)
  (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5e"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk5f"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk60"><span class="nb">rewrite</span> (tunf_eq two); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk61"><span class="kn">Lemma</span> <span class="nf">teq_one_two</span> : teq one eins -&gt; teq two zwei.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins -&gt; teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk62"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins -&gt; teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk63"><span class="nb">intros</span>; <span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk64"><span class="nb">apply</span> teq_fold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk65"><span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>H</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen teq (node <span class="mi">2</span> one two) (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Defined</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk66"><span class="kn">Theorem</span> <span class="nf">teq_eins</span> : teq one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk67"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk68"><span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> teq_two_one, teq_one_two, CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk69"><span class="kn">Theorem</span> <span class="nf">teq_zwei</span> : teq two zwei.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6a"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6b"><span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> teq_one_two, teq_two_one, CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** The following proof would fail guardedness checking at [Qed]-time,</span>
<span class="sd">    because in the proof of the lemma [teq_two_one_bad] the</span>
<span class="sd">    assumption is used &quot;too early&quot;.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6c"><span class="kn">Theorem</span> <span class="nf">teq_eins_bad</span> : teq one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6e"><span class="kr">cofix</span> CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH</var><span class="hyp-type"><b>: </b><span>teq one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> teq_two_one_bad, teq_one_two, CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Abort</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** Compositional proofs using our [pcofix]</span>

<span class="sd">    Using parameterized coinduction, we can state the actual desired</span>
<span class="sd">    lemmas as follows and prove them using [pcofix] (again, only</span>
<span class="sd">    minimal changes to the previous proof scripts are required).</span>
<span class="sd">    Observe that (i) the earlier &quot;wrong&quot; proof of [teq two zwei -&gt; teq</span>
<span class="sd">    one eins] ([teq_two_one_bad]) is _not_ a proof of the</span>
<span class="sd">    corresponding lemma here, and (ii) we are not forced to make the</span>
<span class="sd">    lemmas transparent.</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk6f"><span class="kn">Lemma</span> <span class="nf">teq&#39;_two_one</span> : <span class="kr">forall</span> <span class="nv">r</span>,
  (r two zwei : <span class="kt">Prop</span>) -&gt; paco2 teq_gen r one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : inftree -&gt; inftree -&gt; <span class="kt">Prop</span>,
(r two zwei : <span class="kt">Prop</span>) -&gt; paco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk70"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : inftree -&gt; inftree -&gt; <span class="kt">Prop</span>,
(r two zwei : <span class="kt">Prop</span>) -&gt; paco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk71"><span class="nb">intros</span>; pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk72">pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk73"><span class="nb">rewrite</span> (tunf_eq one), (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) (node <span class="mi">1</span> one two)
  (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk74"><span class="nb">constructor</span>; <span class="nb">auto</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco2 teq_gen r two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk75"><span class="nb">left</span>; pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) two (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk76"><span class="nb">rewrite</span> (tunf_eq two); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) (node <span class="mi">2</span> one two)
  (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk77"><span class="kn">Lemma</span> <span class="nf">teq&#39;_one_two</span> : <span class="kr">forall</span> <span class="nv">r</span>,
  (r one eins : <span class="kt">Prop</span>) -&gt; paco2 teq_gen r two zwei.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : inftree -&gt; inftree -&gt; <span class="kt">Prop</span>,
(r one eins : <span class="kt">Prop</span>) -&gt; paco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk78"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="kr">forall</span> <span class="nv">r</span> : inftree -&gt; inftree -&gt; <span class="kt">Prop</span>,
(r one eins : <span class="kt">Prop</span>) -&gt; paco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk79"><span class="nb">intros</span>; pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7a">pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7b"><span class="nb">rewrite</span> (tunf_eq two), (tunf_eq zwei); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>H</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">teq_gen (upaco2 teq_gen r) (node <span class="mi">2</span> one two)
  (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">constructor</span>; <span class="nb">auto</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">

<span class="sd">(** We now compose them with the help of the lemma [paco2_mult]:</span>
<span class="sd">    - [paco2_mult f : paco2 f (paco2 f r) &lt;2= paco2 f r]</span>

<span class="sd">    The tactic [pmult] applies [paco{n}_mult] to the conclusion</span>
<span class="sd">    for an appropriate [n].</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7c"><span class="kn">Theorem</span> <span class="nf">teq&#39;_eins</span> : teq&#39; one eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7e">pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r one eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r one eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">pmult; <span class="nb">apply</span> teq&#39;_two_one, teq&#39;_one_two, CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk7f"><span class="kn">Theorem</span> <span class="nf">teq&#39;_zwei</span> : teq&#39; two zwei.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk80"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">teq&#39; two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk81">pcofix CIH.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree -&gt; inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH</var><span class="hyp-type"><b>: </b><span>r two zwei</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">paco2 teq_gen r two zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input">pmult; <span class="nb">apply</span> teq&#39;_one_two, teq&#39;_two_one, CIH.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** ** Example: mutual coinduction</span>

<span class="sd">    The third and last example shows that [paco] also works for mutual</span>
<span class="sd">    coinduction.  Here, the mutuality involves two predicates.</span>
<span class="sd">*)</span><span class="c">(* *)</span>


<span class="sd">(** We define two generating functions (using the [inftree] type from</span>
<span class="sd">    before).</span>
<span class="sd">*)</span>

<span class="sd">(** *** A proof via [cofix]</span>

<span class="sd">    Using these, we now define two mutually coinductive predicates</span>
<span class="sd">    [eqone] and [eqtwo].  It is easy to see intuitively that they</span>
<span class="sd">    contain all trees that are equal to [one] and [two] from above,</span>
<span class="sd">    respectively.  We then prove that [eqone] contains [eins].</span>
<span class="sd">*)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">CoInductive</span> <span class="nf">eqone</span> : inftree -&gt; <span class="kt">Prop</span> :=
  | eqone_fold tl tr (EQL : eqone tl : <span class="kt">Prop</span>) (EQR : eqtwo tr : <span class="kt">Prop</span>):
      eqone (node <span class="mi">1</span> tl tr)
<span class="kr">with</span> eqtwo : inftree -&gt; <span class="kt">Prop</span> :=
  | eqtwo_fold tl tr (EQL : eqone tl : <span class="kt">Prop</span>) (EQR : eqtwo tr : <span class="kt">Prop</span>):
      eqtwo (node <span class="mi">2</span> tl tr).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk82"><span class="kn">Lemma</span> <span class="nf">eqone_eins</span> : eqone eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">eqone eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk83" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk83"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">eqone eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk84"><span class="kr">cofix</span> CIH0.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>eqone eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqone eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk85" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk85"><span class="nb">rewrite</span> (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>eqone eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqone (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk86"><span class="nb">constructor</span>; [<span class="nb">apply</span> CIH0|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>eqone eins</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqtwo (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk87" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk87"><span class="kr">cofix</span> CIH1.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>eqone eins</span></span></span><br><span><var>CIH1</var><span class="hyp-type"><b>: </b><span>eqtwo (node <span class="mi">2</span> eins zwei)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqtwo (node <span class="mi">2</span> eins zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk88"><span class="nb">constructor</span>; [<span class="nb">apply</span> CIH0|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>eqone eins</span></span></span><br><span><var>CIH1</var><span class="hyp-type"><b>: </b><span>eqtwo (node <span class="mi">2</span> eins zwei)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqtwo zwei</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk89"><span class="nb">rewrite</span> (tunf_eq zwei).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>eqone eins</span></span></span><br><span><var>CIH1</var><span class="hyp-type"><b>: </b><span>eqtwo (node <span class="mi">2</span> eins zwei)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqtwo (tunf zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">apply</span> CIH1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">


<span class="sd">(** *** A proof via [pcofix]</span>

<span class="sd">    To define the [paco] versions of [eqone] and [eqtwo], we apply</span>
<span class="sd">    the two constructors [paco1_2_0] and [paco1_2_1], respectively (&quot;1&quot;</span>
<span class="sd">    because we are dealing with unary predicates).  Again, the</span>
<span class="sd">    translation of the lemma and of its proof is almost trivial.</span>
<span class="sd"> *)</span>

</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Inductive</span> <span class="nf">eqonetwo_gen</span> <span class="nv">eqonetwo</span> : inftree+inftree -&gt; <span class="kt">Prop</span> :=
  | eqonetwo_left: <span class="kr">forall</span> <span class="nv">tl</span> <span class="nv">tr</span> (<span class="nv">EQL</span>: eqonetwo (inl tl) : <span class="kt">Prop</span>) (<span class="nv">EQR</span>: eqonetwo (inr tr) : <span class="kt">Prop</span>),
      eqonetwo_gen eqonetwo (inl (node <span class="mi">1</span> tl tr))
  | eqonetwo_right: <span class="kr">forall</span> <span class="nv">tl</span> <span class="nv">tr</span> (<span class="nv">EQL</span>: eqonetwo (inl tl) : <span class="kt">Prop</span>) (<span class="nv">EQR</span>: eqonetwo (inr tr) : <span class="kt">Prop</span>),
      eqonetwo_gen eqonetwo (inr (node <span class="mi">2</span> tl tr))
.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8a"><span class="kn">Hint Constructors</span> eqonetwo_gen : core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqone&#39;</span> <span class="nv">t</span> := paco1 eqonetwo_gen bot1 (inl t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Definition</span> <span class="nf">eqtwo&#39;</span> <span class="nv">t</span> := paco1 eqonetwo_gen bot1 (inr t).</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8b"><span class="kn">Hint Unfold</span> eqone&#39; eqtwo&#39; : core.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8c"><span class="kn">Lemma</span> <span class="nf">eqonetwo_gen_mon</span>: monotone1 eqonetwo_gen.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">monotone1 eqonetwo_gen</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8d"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">monotone1 eqonetwo_gen</div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input">pmonauto.</span><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8e" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8e"><span class="kn">Hint Resolve</span> eqonetwo_gen_mon : paco.</label><small class="alectryon-output"><div><div class="alectryon-messages"><blockquote class="alectryon-message">The default value <span class="kr">for</span> hint locality <span class="kr">is</span> currently
<span class="s2">&quot;local&quot;</span> <span class="kr">in</span> a section <span class="kn">and</span> <span class="s2">&quot;global&quot;</span> otherwise, but <span class="kr">is</span>
scheduled to <span class="nb">change</span> <span class="kr">in</span> a future release. For the <span class="kp">time</span>
being, adding hints <span class="kn">outside</span> of sections without
specifying an explicit locality <span class="kr">is</span> therefore
deprecated. It <span class="kr">is</span> recommended to use <span class="s2">&quot;export&quot;</span> whenever
possible.
[deprecated-hint-without-locality,deprecated]</blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">
</span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk8f"><span class="kn">Lemma</span> <span class="nf">eqone&#39;_eins</span>: eqone&#39; eins.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">eqone&#39; eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk90" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk90"><span class="kn">Proof</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion">eqone&#39; eins</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk91">pcofix CIH0; pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree + inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>r (inl eins)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqonetwo_gen (upaco1 eqonetwo_gen r) (inl eins)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk92" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk92"><span class="nb">rewrite</span> (tunf_eq eins); <span class="nb">simpl</span>.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree + inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>r (inl eins)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqonetwo_gen (upaco1 eqonetwo_gen r)
  (inl (node <span class="mi">1</span> eins (node <span class="mi">2</span> eins zwei)))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk93"><span class="nb">constructor</span>; [<span class="nb">right</span>; <span class="nb">apply</span> CIH0|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree + inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>r (inl eins)</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco1 eqonetwo_gen r (inr (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk94" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk94"><span class="nb">left</span>; pcofix CIH1; pfold.</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree + inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>r (inl eins)</span></span></span><br><span><var>CIH1</var><span class="hyp-type"><b>: </b><span>r (inr (node <span class="mi">2</span> eins zwei))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">eqonetwo_gen (upaco1 eqonetwo_gen r)
  (inr (node <span class="mi">2</span> eins zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk95"><span class="nb">constructor</span>; [<span class="nb">right</span>; <span class="nb">apply</span> CIH0|].</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree + inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>r (inl eins)</span></span></span><br><span><var>CIH1</var><span class="hyp-type"><b>: </b><span>r (inr (node <span class="mi">2</span> eins zwei))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco1 eqonetwo_gen r (inr zwei)</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="tutorial-rst-chk96" style="display: none" type="checkbox"><label class="alectryon-input" for="tutorial-rst-chk96"><span class="nb">rewrite</span> (tunf_eq zwei).</label><small class="alectryon-output"><div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><span><var>r</var><span class="hyp-type"><b>: </b><span>inftree + inftree -&gt; <span class="kt">Prop</span></span></span></span><br><span><var>CIH0</var><span class="hyp-type"><b>: </b><span>r (inl eins)</span></span></span><br><span><var>CIH1</var><span class="hyp-type"><b>: </b><span>r (inr (node <span class="mi">2</span> eins zwei))</span></span></span><br></div><span class="goal-separator"><hr></span><div class="goal-conclusion">upaco1 eqonetwo_gen r (inr (tunf zwei))</div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><span class="alectryon-input"><span class="nb">right</span>; <span class="nb">apply</span> CIH1.</span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="kn">Qed</span>.</span></span></pre>
</div>
</div></body>
</html>
